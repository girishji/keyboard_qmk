
# New in C++20

https://www.kdab.com/the-practical-programmers-guide-to-cpp20/

Concepts, Ranges, Modules, Coroutines, and more.

## Concepts

Simply put, a concept specifies the template author’s expectations for how the
template should be used. In C++20, the author adds concepts to define the valid
uses of that template – that is, what types, functions, or other characteristics
are required to use the template properly.

    #include <concepts>
    #include <iostream>

    std::integral auto factorial(std::integral auto a){
        if (a <= 0) return 1;
        else return a * factorial(a - 1);
    }

    int main() {
        std::cout << factorial(10) << std::endl;
        return 0;
    }

Instead of an integer type, we use std::integral. std::integral is a concept, and it tells the
compiler that as long as the parameter conforms to a standard integer type (like
any of the built-in 8-, 16-, 32-, or 64-bit signed or unsigned types), go ahead
and accept this invocation of the function template as valid. In turn, since we
use a concept-enforced std::integral auto as the return type, it ensures our
return type will also be an integer class.

The checking is done at compile time. This is true for all template related checks.

The error generated is highly explanatory and readable, rather than hundreds of
lines of gobbly-gook templates used to produce. Without concepts, the compiler
can’t generate a human understandable error by the time a problem is encountered
deep down in a template’s guts. When you invoke 'factorial(-10.5)':
```
    ismain.cpp:25:15: note: constraints not satisfied
    main.cpp: In function 'int main()':
    main.cpp:50:33: error: use of function 'auto [requires ::Integral<, >] factorial(auto:11) [with auto:11 = double]' with unsatisfied constraints
       50 |     std::cout << factorial(-10.5) << std::endl;
```
## Ranges

Ranges can be thought of as “Unix pipes brought to C++”. It allows functional
programming.

      #include <concepts>
      #include <list>
      #include <print>
      #include <ranges>
      #include <vector>

      int main()
      {
          auto vec = std::views::iota(1, 5)
                   | std::views::transform([](auto const v){ return v * 2; })
                   | std::ranges::to<std::vector>();

          static_assert(std::same_as<decltype(vec), std::vector<int>>);
          std::println("{}", vec);

          auto lst = vec | std::views::take(3) | std::ranges::to<std::list<double>>();
          std::println("{}", lst);
      }

The iota_view function doesn’t generate an array; its iterator generates as many
numbers as you need and only when they’re needed. The pipe syntax of ranges is
also very familiar.

ranges::to

  This range conversion function constructs a new non-view object from a source range.

views::take

  1) A range adaptor that represents view of the elements from an underlying
  sequence, starting at the beginning and ending at a given bound.

  2) views::take is a RangeAdaptorObject. The expression views::take(e, f)
  results in a view that represents the first f elements from e.

## Views

Views are lazy evaluation for ranges. You can use them is in for-loops like this:

    for (auto [i, j] : views::cartesian_product(views::iota(0, m), views::iota(0, n))) {
        // (0, 0), (0, 1) ...
    }

## Coroutines

Coroutines can be interrupted. They can wait for some condition and then resume.
Python's generator is available in C++ through coroutines.


## Modules

... Skipped ...

## Others

### std::format

Formatted strings can now be easily created just like in Python.

    std::cout << std::format("{1}, {0}!\n", "world", "hello");
    std::cout << std::format("he{0}{0}o, {1}!\n", "l", "world");

### Three Way Comparison Operator\<=>

Just like strcmp(), it communicates less than (negative value), equals (zero),
and greater than (positive value) status in a single call. The\<=> is also
called the spaceship operator.

We didn’t even have to write our type’s spaceship function – using 'default'
allows the compiler to synthesize one in many simple cases. We get all 18
operators for “free” because the compiler now converts all comparison operations
into spaceship automatically. When the compiler sees A\< B, it silently
interprets that as (A\<=> B)\< 0, and similarly transforms any other comparison
operator.

==============================================================================
vim:tw=80:ts=4:ft=markdown:ai:
